Функциональное ООП
===
Как всё началось
---
Длительное время занимался исследованиями различных ЯП и подходов, в том числе на практике.
Тогда выполнял работы преимущественно в области веб-программирования, следовательно основным средством стал JavaScript.
В итоге начал замечать что часть кода который появиля в одном из проектов я копирую в другие проекты.
Особенно это касается тех частей кода которые используется исключительно для отладки.

Когда размер этого кода перевалил на килобайт, решил организовать его в отдельный файл, заодно дополнив редко востребоваными полезностями.

Так как я в то время активно использовал CoffeeScript для собственных наработок, не стал делать исключение и тут.

Собственно почему CoffeeScript?
Основное преимущество кофескрипта в лаконичной и компактной записи объявления функций.
Это позволяет более наглядно оперировать функциями как значениями, следовательно это способствует написанию кода в стиле функционального программирования.
В итоге мой набор инстументов написан именно в этом стиле.

Простейшие инструменты
---
Очень часто требуется повторить вычисление определённое количество раз.
И что сразу может прийти на ум.
```coffeescript
times = (count, fn)->
	fn i for i in [0...count]
	return
timesA = (count, fn)->
	fn i for i in [0...count]
```
Так же часто необходимо слить массивы или объекты.
```coffeescript
zip = (a, b, fn)->
	size = Math.max a.length, b.length
	fn i, a[i], b[i] for i in [0...size]
zipObects = (a,b,fn)->
	for k of a
		fn k, a[k], b[k]
```
И много других подобных полезностей.

Методы функций
---
У яваскрипта есть множестово характерных особенностей которые дают возможность придерживаться того или иного стиля.

Эти особенности сказались на моём стиле:
* функции могут присваиватся переменным
* функции могут передаваться как аргументы
* функции могут возвращаться как значениями
* у функций могут быть поля, а значит и методы
* this доступен у всех функций, следовательно любую функцию можно использовать как метод
* прототип и конструктор у функции можно заменить
* функции могут применяться в качестве конструкторов типов данных

Так же важной особенностью является то что стандартные конструкторы и прототипы можно заменять и модифицировать.
Однако этого стоит избегать ввиду того что это непредсказуемо сказывается на работе стороннего кода.

Учитывая всё это можно сформулировать следуюющие требования
* на основе функции получать новые функции вызывая её методы
* метод вычисленый из метода может приметься как метод
* исходные функции не изменяются
* из функции вычисленой из конструктора есть возможноть получить конструктор

В итоге нам потребуется функция - декоратор возвращающая функцию с набором методов возвращающих такие же функции.
На основании этого можно строить цепочки функциональных вычислений.
