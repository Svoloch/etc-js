Сборник полезных утилит для JavaScript
==

Предыстория
--
Я длительное время писал код на JS и при этом собирал часто
используемые фрагменты кода в один файл, чтобы было легче
копипастить. В итоге этот набор разросся до такого объёма, что его
стало целесообразно оформить как библиотеку.

Основная концепция
--
Функции - такие же значения, как и всё остальное, а, следовательно, их
можно вычислять.

Все функции используют `this` и, следовательно, могут быть
использованы как методы. Таким образом, функции, вычисленные из других
функций, также могут использовать `this` и быть использованными в
качестве методов.

Особенности реализации
--
Большинство представленных алгоритмов используют элементарный набор
возможностей. Оказалось, что для библиотеки не требуются возможности
ECMAScript5, так что она базируется на возможностях, которые имеются в
ECMAScript3.

Архитектура библиотеки предполагает использовать её "как есть". Вместо
модификации кода библиотеки рекомендуется реализоввывать дополнения и
расширения к ней. Можно смело подменять поведение любых функций вплоть
до полной их замены. Также библиотеку можно дополнять новыми функциями
и применять к её классам паттерн "наследование".

Почему CoffeeScript
--
Можно было бы написать данную библиотеку на оригинальном JavaScript,
однако на CoffeeScript писать проще, короче и быстрее. В общем, было
принято решение не создавать себе сложностей и использовать более
удобный синтаксис.

Почти все примеры кода в данном руководстве будут на
CoffeeScript. Если по ним возникнут вопросы - всегда можно зайти на
[coffeescript.org] и воспользоваться веб-интерфейсом для
преобразования кода в JavaScript.

Декоратор `$F`
--
В целях избежания модификации `Function.prototype` был использован
декоратор `$F`. Он создаёт из функции функцию, делающую то же самое,
но при этом имеющую набор дополнительных методов. Это работать с
оригинальной функцией так же, как и раньше; она может являться
экземпляром любого ранее созданного типа и это не помешает работать с
ней методами, определёнными в данной библиотеке.

Прототип-модификатор `$F.prototype`
--
Для того, чтобы работали встроенные в JavaScript возможности ООП,
необходимо, чтобы прототип типа данных, основаного на функциях, также
был функцией. Можно было бы использовать для этого произвольную
функцию, но мне понадобилась функция, которая прикрепляет необходимый
интерфейс к существующим функциям, а придумать для неё подходящее
название было проблематично. Таким образом, в прототип поместил
функцию, прикрепляющую конструктор `$F` к заданой функции.

`$F.prototype.then`
--
Позволяет после выполнения текущей функции вызвать следующую с
результатом работы текущей функции в качестве аргумента.

Визуально это выглядит как смена порядка применения унарных функций. Например,
```coffeescript
do $F(->"example").then(alert)
```
работает так же, как
```coffeescript
alert "example"
```

`$F.prototype.catch`
--
Исключение - такой же результат работы вычислительного алгоритма, как
и возвращённое значение. Более того, исключения представляют собой
неотемлемыю часть API как стандартных библиотек, так и многих
других. Поскольку это результат функции, то и обрабатываться он должен
как результат функции.

Функция `catch` устанавливает обработчик исключений, вызванных
функцией, что облегчает дальнейшее использование в вычислениях этого
выброшенного исключения.
```coffeescript
parseJSON = $F(JSON.parse).catch ->null
```
аналогично
```coffeescript
parseJSON = (str)->
	try JSON.parse str
	catch then null
```

`$F.prototype.bind`
--
В стандартном наборе ECMAScript5 этот метод возращает функцию;
следовательно, в нашем случае эта функция должна иметь соответствующий
API. В ECMAScript3 такого метода нет, однако он очень полезен, так что
должен быть частью библиотеки.

`$F.prototype.bindArgs`
--
Позволяет получить функцию, к которой применены указаные аргументы.

`$F.prototype.bindArgsStrict`
--
Позволяет получить функцию, игнорирующую агументы. По такому же
принципу, по которому результат работы `bind` игнорирует `this`.

`$F.prototype.catchCond`
--
Часто библиотека или просто часть приложения использует в своей работе
исключения. Однако, в большинстве случаев их интересуют только их
собственные исключения, остальные предоставляются другим частям кода.
Данный метод позволяет отфильтровать возникшие исключения по условию.

`$F.prototype.catchVal`
--
Для возрата управления через исключения часто используются специальные
значения. Этот метод позволяет их учитывать.

`$F.prototype.catchType`
--
Фильтрует исключения по их типу.

`$F.prototype.default`
--
Подставляет переданное значение как результат работы алгоритма при
возникновении исключения.

`$F.prototype.loop`
--
Повторяет функцию до возникновения исключения. В некоторых случаях
удобно использовать вместо циклов.

`$F.prototype.times`
--
Повторяет функцию указанное количество раз, помещая результат в
результирующий массив. Удобная замена для циклов.

Также позволяет указать `this` вторым аргументом. Например:
```coffeescript
$F(->"\t").times(10).join ""
```
работает как
```coffeescript
(for x in [0...10] then "\t").join ""
```

`$F.prototype.repeat`
--
Просто повторяет функцию заданное количество раз. Для удобства
использования возращает её же.

`this` передаётся вторым аргументом.

`$F.prototype.curry`
--
Реализует частичное применение функции. Превращает функцию в цепочку
функций с одним аргументом, возвращающих функции. Глубину вложенности
можно задавать.

`$F.prototype.bindedCurry`
--
При использовании `curry` теряется связь с объектом `this`, в качестве
метода которого эта функция была вызвана. Чтобы устранить этот
недостаток, данный объект может быть прикреплён к функции при первом
вызове. Таким образом, результат работы каррированой функции удобно
использовать в качестве метода.

`$F.prototype.curryBreak`
--
Работает наподобие `curry`, однако список аргументов разбивается не по
одному, а диапазонами. Рекомендуется использовать с API, в котором у
функций достаточно большое количество аргументов.

`$F.prototype.preprocessAll`
--
Это функция по большей части вспомогательная. Принимает функцию,
принимающую массив и возращающую массив. Используется для замены
списка аргументов функции. Можно использовать для работы с различными
API.

`$F.prototype.flip`
--
Меняет местами аргументы с указаными номерами.

`$F.prototype.preprocess`
--
Принимает функции, которые применяются к первым аргументам итоговой
функции. Можно использовать как обёртку над различными API, чтобы
привести аргументы к допустимой форме.

`$F.prototype.preprocessStrict`
--
Делает то же самое, что и `preprocess`, но аргументы, для которых не
указан колбек, игнорируются.

`$F.prototype.guard`
--
Проверяет результат на соответствие условию. В случае несоответствия
бросает исключение типа `$F.Error`.

Примечание: Название функции возможно поменяется. Также планируется
доработать иерархию исключений в расчёте на упрощение отладки.

`$F.prototype.guardType`
--
Проверяет тип результата работы функции. В случае несоответствия
бросает исключение типа `$F.Error`.

`$F.prototype.guardArguments`
--
Проверяет аргументы на соответствие условиям. В случае несоответствия
бросает исключение типа `$F.Error`.

`$F.prototype.guardArgumentsTypes`
--
Проверяет типы аргументов на соответствие условиям. В случае
несоответствия бросает исключение типа `$F.Error`.

`$F.prototype.zipper`
--
Порождает функцию, принимающую массивы и выдающую массив, элементы
которого являются результатами применения исходной функции к элементам
заданных массивов.

Результат работы `zipper` может использоваться в качестве метода.

`$F.prototype.zip`
--
Объединяет массивы с помощью данной функции.

`$F.prototype.zipWith`
--
То же, что и `zip`, но первым аргументом идёт объект, который будет
использоваться в качестве `this`.

Примечание: Необходимость данной функции сомнительна; возможно, она
будет удалена. К тому же, под сомнением и её название.

`$F.prototype.objectZipper`
--
Аналог `zipper`, но для объектов. Можно указать объект-приёмник. В
качестве приёмника можно использовать один из входных
параметров для модификации его полей.

`$F.prototype.zipObjects`
--
Применяет текущую функцию для объединения объектов.

`$F.prototype.zipObjectsWith`
--
Объединяет объекты; первым аргументом задаётся `this`.

`$F.prototype.zipObjectsTo`
--
Объединяет объекты, используя первый аргумент в качестве приёмника.

`$F.prototype.cell`
--
Реализует API, подобное клеткам в Clojure. В качестве параметров
указываются другие клетки, значения которых передаются текущей
функции.

Примечание: В данную библиотеку слабо вписывается; возможно, будет
вынесено отдельно в отдельный пакет.

`$F.prototype.fnFlip`
--
Меняет порядок применения аргументов для функции, возвращающей функцию.

`$F.commonKeys`
--
Выдаёт массив ключей, общих для указанных объектов. Используется в
`objectZipper`, однако полезна сама по себе.

`$F.as`
--
Проверяет, является ли второй аргумент типом первого. В качестве типа
можно задавать как конструкторы, так и строковые аналоги (используется
`typeof`).

`$F.cell`
--
Реализует API, подобное клеткам в Clojure. Создаёт клетку, значение
которой можно менять.

Примечание: В данную библиотеку слабо вписывается; возможно, будет
вынесено отдельно в качестве дополнения.

`$F.inherit`
--
Возвращает декоратор с поведением как у `$F`. По сути, это его
потомок.

`$F.Error`
--
В дальнейшем планируется реализовать набор исключений для упрощения
отладки внутри библиотеки. Сейчас это только заглушка.

[coffeescript.org]:http://coffeescript.org